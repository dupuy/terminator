#!/bin/bash
#
# Generate frozen requirements file
#
":" """Shell script that invokes itself as Python script as well"""

# This works for shell or Python only if no spaces around '=' (sorry, no PEP8)
REQS='.reqs'                    # pylint: disable=C0322

# This is also a python script (`python $0` below); next line skips shell stuff
if ':' '': r'''#'; then :; fi

if [ "$#" -lt 2 ]; then
  echo >&2 "Usage: freeze REQUIREMENTS REQFILES..."
  exit 1
fi

set -e
trap '[ "$?" != 127 ] && echo >&2 $0: "\"$BASH_COMMAND\" failed ($?)"' ERR

REQUIRE=$1
shift

# trap removes partial/empty target on failure
settrap() { trap 'if [ "$?" != 0 ]; then rm -f $REQUIRE; fi' 0; }

MSG="# Generated by 'make ${REQUIRE##*/}' from requirements/$*
# You should not need to edit this file - see requirements/README.rst"

# create .reqs, clean out non-cache files in top-level
mkdir $REQS 2>/dev/null || rm -rf $REQS/env &&
 find $REQS \( -name env -prune \) -o ! -name '*%*' -type f -print |
  xargs rm -f

# run this as Python to get ARGS= for pip install and E= for additional output
eval `python $0 "$@"`

# guarantee we are downloading everything
virtualenv --no-site-packages --clear $REQS/env
source $REQS/env/bin/activate

case `pip --version` in
  "pip 0"*|"pip 1.[012]"*)
    echo "starting clean install of requirements from PyPI (please be patient)"
    (cd $REQS && pip install --download-cache . $ARGS)
    settrap
    { echo "$MSG"
      pip freeze | LC_ALL=C sort |
       egrep -v "@`git rev-parse HEAD`|^wsgiref=="; } > $REQUIRE ;;
  *)
    # only pip 1.3.1+ processes --download recursively
    echo "starting download of requirements from PyPI (please be patient)"
    (cd $REQS && pip install --download-cache . --download . $ARGS)
    settrap
    (cd $REQS &&
     { echo "$MSG"
       printf '%s' "$E" | LC_ALL=C sort
       ls *.tar* | sed -e '/%/d' -e 's/-\([0-9]\)/==\1/' -e 's/.tar.*$//' |
       LC_ALL=C sort; }
    ) > $REQUIRE ;;
esac

exit
'''.startswith('')

# Python script to combine all requirement specs from multiple files

# Pip behavior with overlapping specifications like "South<0.8,<2.0" (with two
# maximums) or "South!=0.8,<0.8" (with identical maximum and exclude) is to
# ignore the lower maximum in the first case, and discard the maximum in favor
# of the exclusion in the second case.  This behavior means that we can't just
# add a more restrictive maximum and expect it to have any effect.
#
# This is an issue because we need to incorporate stricter version maximums
# for older Python (as specified in py*.txt files) - these must be combined as
# pip complains about duplicated specifications that appear in multiple files
# (even if they are compatible).
#
# To handle these problems and get pip to download correct versions for
# requirements, this Python script parses through all input requirements files
# (following -r lines recursively) and generates (in the $REQS directory, with
# -r lines commented out) a merged requirements file for each non-py*.txt
# input.  It prints to stdout a shell expression for eval to set arguments
# (ARGS) with -r for each merged output file, and an extra variable (E) used
# to capture all "-e VCS-URL" lines that are not downloaded with (the faster)
# --download, so that they can be output in final requirements.txt as well.

import fileinput
import os
import re
import sys

try:
    from distutils.version import NormalizedVersion  # pylint: disable=E0611
except (ImportError):
    try:
        from verlib import NormalizedVersion  # pylint: disable=F0401
    except (ImportError):
        from distutils.version import LooseVersion

        class NormalizedVersion(LooseVersion):  # pylint: disable=R0903
            """Hashable subclass of LooseVersion that can be put in set()"""
            def __hash__(self):
                return hash(str(self))

LINE_RE = re.compile(r"""
                     ([^][<!=>,\s]+)     # package name
                     (?:\[([^]]+)\])?    # [extra,opts]
                     (.*)                # >=1.2,<=2.0 etc.
                     """, re.VERBOSE)
VERS_RE = re.compile(r"""
                     ,?                  # leading comma, if any
                     ((?:>=?|[!=]=|<=?)  # >=, ==, etc.
                      [^,<!=>]+)         # 1.2, 2.0 etc
                     """, re.VERBOSE)


class Spec(object):
    """A version specification"""
    def __init__(self, name, extras=''):
        self._name = name
        self._extras = set(extras.split(',') if extras else {})
        self._min = None
        self._max = None
        self._maxeq = False     # True if <=_max limit (or ==vers)
        self._exc = set()
        self.used = False

    def __str__(self):
        """
        >>> from freeze import Spec
        >>> str(Spec('foo',extras='bar'))
        'foo[bar]'
        >>> str(Spec('foo','bar').addextras('baz'))
        'foo[bar,baz]'
        >>> str(Spec('foo',extras='bar').addvers('>=1.0'))
        'foo[bar]>=1.0'
        >>> str(Spec('foo','bar').addextras('baz').addvers('==1.0'))
        'foo[bar,baz]==1.0'
        >>> str(Spec('foo').addvers('>0.1'))
        Traceback (most recent call last):
        ValueError: Minimum (>0.1) must be specified with >=
        >>> str(Spec('foo').addvers('<0.4'))
        'foo<0.4'
        >>> str(Spec('foo').addvers('<=0.4'))
        'foo<=0.4'
        >>> str(Spec('foo').addvers('>=0.1').addvers('!=0.2').addvers('<0.3'))
        'foo>=0.1,!=0.2,<0.3'
        >>> str(Spec('foo').addvers('!=0.4').addvers('>=0.4'))
        'foo>=0.4,!=0.4'
        >>> str(Spec('foo').addvers('!=0.4').addvers('>=0.5'))
        'foo>=0.5'
        >>> str(Spec('foo').addvers('!=0.4').addvers('<=0.5'))
        'foo!=0.4,<=0.5'
        >>> str(Spec('foo').addvers('!=0.4').addvers('<=0.4'))
        'foo<0.4'
        >>> str(Spec('foo').addvers('!=0.4').addvers('<0.4'))
        'foo<0.4'

        """

        text = self._name
        if self._extras:
            text += "[" + ','.join(sorted(self._extras)) + "]"
        verslist = []
        if self._min is not None:
            if self._maxeq and (self._max is not None and
                                self._min == self._max):
                verslist.append("==" + str(self._min))
            else:
                verslist.append(">=" + str(self._min))
        for ver in self._exc:
            if self._max is not None:
                if self._maxeq and ver == self._max:
                    self._maxeq = False
                    continue
                if ver >= self._max:
                    continue
            if self._min is None or ver >= self._min:
                verslist.append("!=" + str(ver))
        if self._max is not None:
            if not self._maxeq:
                verslist.append("<" + str(self._max))
            elif self._min is None or self._max != self._min:
                verslist.append("<=" + str(self._max))
        return text + ",".join(verslist)

    def __repr__(self):
        return str(self) + (" {<=%s/%s}" % (str(self._maxeq), self.used))

    def addextras(self, extras):
        """Add extras ([PDF,postgres]) to Spec object"""
        for ext in extras.split(',') if extras else []:
            self._extras.add(ext)
        return self

    def addvers(self, vers):
        """Add a version spec (>1.2) to Spec object"""
        vers = vers.strip(" ")
        vers = vers.strip(",")
        if vers.startswith(">="):
            self.addmin(vers[2:])
        elif vers.startswith(">"):
            raise ValueError("Minimum (%s) must be specified with >=" % (vers))
        elif vers.startswith("<="):
            self.addmax(vers[2:], inclusive=True)
        elif vers.startswith("<"):
            self.addmax(vers[1:])
        elif vers.startswith("=="):
            self.addmin(vers[2:])
            self.addmax(vers[2:], inclusive=True)
        elif vers.startswith("!="):
            self._exc.add(NormalizedVersion(vers[2:]))
        return self

    def addmin(self, vers):
        """Update minimum version if new one is higher"""
        newmin = NormalizedVersion(vers)
        if not self._min or newmin > self._min:
            self._min = newmin

    def addmax(self, vers, inclusive=False):
        """Update maximum version if new one is lower"""
        newmax = NormalizedVersion(vers)
        if not self._max or (newmax < self._max or
                             (not inclusive and newmax == self._max)):
            self._max = newmax
            self._maxeq = inclusive

ARGS = []
E = set()

FILES = sys.argv[1:]
SEEN = set()
SPECS = {}


def process_files():            # pylint: disable=R0912
    """Recursively process input files specified on command line """
    out = None

    while FILES:
        for line in fileinput.input([FILES.pop(0)]):
            if fileinput.isfirstline():
                filename = os.path.basename(fileinput.filename())
                if filename in SEEN:
                    fileinput.nextfile()
                    continue

                SEEN.add(filename)

                # Close out and set to None (if not already None)
                out = out and out.close()

                if not filename.startswith("py"):
                    outfilename = os.path.join(REQS, filename)
                    out = open(outfilename, 'w')
                    ARGS.append("-r %s" % (filename))

            if line.strip() == '' or line.startswith("#"):
                if out is not None:
                    out.write(line)

            elif out is None and line.startswith("-"):
                sys.stderr.write("%s:%d: Invalid line in py* reqfile: %s\n" %
                                 (filename, fileinput.filelineno(), line))
                sys.exit(1)

            elif line.startswith("-e"):
                E.add(line)
                out.write(line)

            elif line.startswith("-r"):
                FILES.append(line[2:].strip())
                out.write("#" + line)

            else:
                process_req(line, out, filename)

    fileinput.close()

    out = out and out.close()

    filename = "py.txt"
    outfilename = os.path.join(REQS, filename)
    out = open(outfilename, 'w')
    ARGS.append("-r %s" % (filename))
    for spec in SPECS.values():
        if not spec.used:
            out.write(str(spec) + "\n")


def process_req(line, out, filename):
    """Process a single normal line of a requirements file"""
    line = line.strip()
    match = re.match(LINE_RE, line)
    if not match:
        sys.stderr.write("%s:%d: Bad reqfile line: %s\n" %
                         (filename, fileinput.filelineno(), line))
        if out is None:
            sys.exit(1)
        else:
            out.write(line + "\n")

    else:
        pkg = match.group(1)
        extra = match.group(2)
        version = match.group(3)
        spec = SPECS.get(pkg, None)
        if spec is None:
            spec = Spec(pkg, extras=extra)
            SPECS[pkg] = spec
        else:
            spec.addextras(extra)

        mvers = re.match(VERS_RE, version)
        while mvers:
            spec.addvers(mvers.group(1))
            version = mvers.string[mvers.end():]
            mvers = re.match(VERS_RE, version)

        # sys.stderr.write(repr(spec) + "\n")

        if out is not None:
            out.write(str(spec) + "\n")
            if not spec.used:
                # mark used with original file:line information
                spec.used = (" %s:%d" % (filename, fileinput.filelineno()))
            else:
                sys.stderr.write("%s:%d: Dupe entry for %s:%s\n" %
                                 (filename, fileinput.filelineno(),
                                  pkg, spec.used))

if __name__ == '__main__':

    try:
        if not os.path.isdir(REQS):
            os.makedirs(REQS)

        process_files()
    except (ValueError):
        sys.stderr.write(("%s:%d: Error: " %
                          (fileinput.filename(), fileinput.filelineno())) +
                         str(sys.exc_info()[1]) + "\n")
        sys.exit(1)
    except (IOError, OSError):
        sys.stderr.write(str(sys.exc_info()[1]) + "\n")
        sys.exit(1)

    print("E='" + ''.join(E) + "' ARGS='" + '\n'.join(ARGS) + "'")
    sys.exit(0)
